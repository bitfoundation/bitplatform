# Stage 20: .NET Aspire

Welcome to Stage 20! In this stage, we'll explore how .NET Aspire is integrated into the boilerplate project and how it simplifies local development, service orchestration, and infrastructure management for distributed applications.

## What is .NET Aspire?

.NET Aspire is a cloud-native development stack designed to simplify building resilient, distributed applications. It provides:

- **Local Development Orchestration**: Manages the startup and interconnections of various services in your distributed application
- **Service Discovery**: Automatically handles how different parts of your application find and communicate with each other
- **Infrastructure Provisioning**: Provisions and configures infrastructure resources like databases and storage for local development
- **Observability**: Integrated OpenTelemetry support for logs, metrics, and distributed tracing

## Project Structure

When .NET Aspire is enabled in this template (via the `aspire` parameter), the following key projects and configurations are included:

### Boilerplate.Server.AppHost

**Location**: `/src/Server/Boilerplate.Server.AppHost/`

This is the orchestration project that manages all your application's resources and dependencies. Let's look at its key files:

#### Boilerplate.Server.AppHost.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">

    <Sdk Name="Aspire.AppHost.Sdk" Version="9.5.2" />

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net10.0</TargetFramework>
        <IsAspireHost>true</IsAspireHost>
        <EntryPointAccessibility>public</EntryPointAccessibility>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Aspire.Hosting.AppHost" />
        <PackageReference Include="Aspire.Hosting.DevTunnels" />
        <PackageReference Include="Aspire.Hosting.MySql" />
        <PackageReference Include="CommunityToolkit.Aspire.Hosting.MailPit" />
        <PackageReference Include="CommunityToolkit.Aspire.Hosting.Sqlite" />
        <PackageReference Include="Aspire.Hosting.SqlServer" />
        <PackageReference Include="Aspire.Hosting.PostgreSQL" />
        <PackageReference Include="Aspire.Hosting.Azure.Storage" />
        <PackageReference Include="CommunityToolkit.Aspire.Hosting.Minio" />
    </ItemGroup>

</Project>
```

**Key Points**:
- Uses the `Aspire.AppHost.Sdk` which provides tooling for orchestration
- Includes hosting packages for databases (MySQL, SQLite, SQL Server, PostgreSQL)
- Includes hosting packages for storage (Azure Blob Storage, MinIO for S3)
- Includes hosting packages for development tools (MailPit, Dev Tunnels)
- The packages are conditionally included based on template parameters (database, filesStorage)

#### Program.cs

**Location**: `/src/Server/Boilerplate.Server.AppHost/Program.cs`

This is where you define and configure all your application's resources:

```csharp
var builder = DistributedApplication.CreateBuilder(args);

// Example: PostgreSQL with pgAdmin and pgvector support
var postgresDatabase = builder.AddPostgres("postgresserver")
    .WithPgAdmin(config => config.WithVolume("/var/lib/pgadmin/Boilerplate/data"))
    .WithDataVolume()
    .WithImage("pgvector/pgvector", "pg18")
    .AddDatabase("postgresdb");

// Example: Azure Blob Storage (Azurite emulator)
var azureBlobStorage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite => azurite.WithDataVolume())
    .AddBlobs("azureblobstorage");

// Server Web Project
var serverWebProject = builder.AddProject("serverweb", "../Boilerplate.Server.Web/Boilerplate.Server.Web.csproj")
    .WithExternalHttpEndpoints();

if (builder.Environment.IsDevelopment())
{
    serverWebProject.WithHttpHealthCheck("/alive");
}

// Server API Project (if standalone API is enabled)
var serverApiProject = builder.AddProject("serverapi", "../Boilerplate.Server.Api/Boilerplate.Server.Api.csproj")
    .WithExternalHttpEndpoints();

// Wire up dependencies
serverWebProject.WithReference(serverApiProject);
serverApiProject.WithReference(postgresDatabase).WaitFor(postgresDatabase);
serverApiProject.WithReference(azureBlobStorage);

// Development-only resources
if (builder.ExecutionContext.IsRunMode)
{
    // Blazor WebAssembly Standalone project
    builder.AddProject("clientwebwasm", "../../Client/Boilerplate.Client.Web/Boilerplate.Client.Web.csproj")
        .WithExplicitStart();

    // MailPit for testing emails
    var mailpit = builder.AddMailPit("smtp")
        .WithDataVolume("mailpit");
    
    serverApiProject.WithReference(mailpit);

    // Blazor Hybrid Windows project
    builder.AddProject("clientwindows", "../../Client/Boilerplate.Client.Windows/Boilerplate.Client.Windows.csproj")
        .WithExplicitStart();

    // Dev Tunnels for testing OAuth callbacks, webhooks, and mobile apps
    var tunnel = builder.AddDevTunnel("web-dev-tunnel")
        .WithAnonymousAccess()
        .WithReference(serverWebProject.WithHttpEndpoint(name: "devTunnel").GetEndpoint("devTunnel"));
}

await builder.Build().RunAsync();
```

**Key Concepts**:

1. **Resource Declaration**: Define your infrastructure resources (databases, storage, etc.)
2. **Project References**: Add your application projects (`AddProject`)
3. **Dependencies**: Wire up dependencies using `WithReference()` and `WaitFor()`
4. **Health Checks**: Monitor service health with `WithHttpHealthCheck()`
5. **Development Resources**: Add development-only tools using `IsRunMode` check

### Boilerplate.Server.Shared

This project acts as the **ServiceDefaults** project in Aspire terminology. It contains common configuration shared between your server projects.

**Location**: `/src/Server/Boilerplate.Server.Shared/Extensions/WebApplicationBuilderExtensions.cs`

The `AddServiceDefaults()` method configures:
- **Service Discovery**: Automatically discover and connect to services
- **OpenTelemetry**: Logging, metrics, and distributed tracing
- **Resilience**: HTTP client resilience patterns (optional)
- **Health Checks**: Application health monitoring

```csharp
private static TBuilder AddServiceDefaults<TBuilder>(this TBuilder builder)
    where TBuilder : IHostApplicationBuilder
{
    builder.ConfigureOpenTelemetry();

    builder.Services.AddServiceDiscovery();

    builder.Services.ConfigureHttpClientDefaults(http =>
    {
        http.ConfigureHttpClient(httpClient =>
        {
            httpClient.DefaultRequestVersion = HttpVersion.Version20;
            httpClient.DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrHigher;
        });

        // Turn on service discovery by default
        http.AddServiceDiscovery();

        http.UseSocketsHttpHandler((handler, sp) =>
        {
            handler.EnableMultipleHttp2Connections = true;
            handler.EnableMultipleHttp3Connections = true;
            handler.PooledConnectionLifetime = TimeSpan.FromMinutes(15);
            handler.AutomaticDecompression = DecompressionMethods.All;
        });
    });

    return builder;
}
```

## Configuration

### appsettings.Development.json

**Location**: `/src/Server/Boilerplate.Server.AppHost/appsettings.Development.json`

```json
{
    "Parameters": {
        "sqlserver-password": "P@ssw0rd",
        "postgresserver-password": "P@ssw0rd",
        "mysqlserver-password": "P@ssw0rd",
        "s3-rootPassword": "P@ssw0rd",
        "Comment": "You might need to delete the docker volumes to apply changes to the passwords"
    }
}
```

**Important**: These credentials are for **local development only**. In production, you would use secure secret management solutions.

### Connection String Override

When you run `Boilerplate.Server.AppHost`, it **automatically overrides** the connection strings in your application projects at runtime. This is mentioned in:

**Location**: `/src/Server/Boilerplate.Server.Api/appsettings.json`

```json
{
    "Aspire__Comment": "Running Boilerplate.Server.AppHost `overrides` the following connection strings at runtime."
}
```

You don't need to manually configure connection strings when using Aspire - it handles this automatically through service discovery and environment variables.

## Key Features and Benefits

### 1. Database Management with Admin Tools

Aspire automatically provisions databases with integrated admin tools and persistent storage:

#### SQL Server
- **Image**: `mssql/server:2025-latest` (with embedded vector search support)
- **Admin Tool**: DbGate (with data volume persistence)
- **Data Persistence**: Docker volumes ensure data survives container restarts

```csharp
var sqlDatabase = builder.AddSqlServer("sqlserver")
    .WithDbGate(config => config.WithDataVolume())
    .WithDataVolume()
    .WithImage("mssql/server", "2025-latest")
    .AddDatabase("mssqldb");
```

#### PostgreSQL
- **Image**: `pgvector/pgvector:pg18` (with pgvector for vector embeddings)
- **Admin Tool**: pgAdmin (with data volume persistence)
- **Data Persistence**: Docker volumes

```csharp
var postgresDatabase = builder.AddPostgres("postgresserver")
    .WithPgAdmin(config => config.WithVolume("/var/lib/pgadmin/Boilerplate/data"))
    .WithDataVolume()
    .WithImage("pgvector/pgvector", "pg18")
    .AddDatabase("postgresdb");
```

#### MySQL
- **Admin Tool**: phpMyAdmin (with data volume persistence)
- **Data Persistence**: Docker volumes

```csharp
var mySqlDatabase = builder.AddMySql("mysqlserver")
    .WithPhpMyAdmin(config => config.WithVolume("/var/lib/phpMyAdmin/Boilerplate/data"))
    .WithDataVolume()
    .AddDatabase("mysqldb");
```

#### SQLite
- **Admin Tool**: SQLite Web (with data volume persistence)
- **File**: `BoilerplateDb.db`

```csharp
var sqlite = builder.AddSqlite("sqlite", databaseFileName: "BoilerplateDb.db")
    .WithSqliteWeb(config => config.WithVolume("/var/lib/sqliteweb/Boilerplate/data"));
```

### 2. File Storage Management

#### Azure Blob Storage (Azurite Emulator)
```csharp
var azureBlobStorage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite => azurite.WithDataVolume())
    .AddBlobs("azureblobstorage");
```

#### S3 (MinIO)
```csharp
var s3Storage = builder.AddMinioContainer("s3")
    .WithDataVolume();
```

### 3. MailPit - Email Testing

MailPit provides a local SMTP server with a web UI for inspecting outgoing emails during development:

```csharp
var mailpit = builder.AddMailPit("smtp")
    .WithDataVolume("mailpit");

serverApiProject.WithReference(mailpit);
```

**Benefits**:
- No need for external SMTP server during development
- Web UI to view all sent emails
- Test email functionality without sending real emails

### 4. Dev Tunnels - Public HTTPS URLs

Dev Tunnels create public HTTPS URLs for your local application, enabling:
- Testing OAuth callbacks with external providers
- Testing webhooks from external services
- Testing mobile applications that need to connect to your local backend

```csharp
var tunnel = builder.AddDevTunnel("web-dev-tunnel")
    .WithAnonymousAccess()
    .WithReference(serverWebProject.WithHttpEndpoint(name: "devTunnel").GetEndpoint("devTunnel"));
```

### 5. Health Checks Dashboard

Aspire provides a dashboard to monitor health endpoints of all your services:

```csharp
if (builder.Environment.IsDevelopment())
{
    serverWebProject.WithHttpHealthCheck("/alive");
    serverApiProject.WithHttpHealthCheck("/alive");
}
```

**Security Note**: The code above ensures health check endpoints are only enabled in development environments to avoid security implications in production.

### 6. Aspire Dashboard - Observability

When you run the AppHost project, Aspire automatically opens a dashboard that provides:

- **Logs**: Real-time logs from all services with filtering and search
- **Metrics**: Performance metrics (CPU, memory, request counts, etc.)
- **Traces**: Distributed tracing across your microservices
- **Resources**: Overview of all running resources (databases, storage, projects)
- **Console Output**: Console output from all projects

**Access**: The dashboard URL is displayed in the console when you start the AppHost project (typically `http://localhost:15XXX`)

## Integration with Tests

Aspire is also integrated into the test project to closely mimic a production environment.

**Location**: `/src/Tests/TestsInitializer.cs`

```csharp
private static async Task RunAspireHost(TestContext testContext)
{
    var aspireBuilder = await DistributedApplicationTestingBuilder
        .CreateAsync<Program>(testContext.CancellationToken);

    // Remove project resources (we'll use AppTestServer instead)
    foreach (var res in aspireBuilder.Resources.OfType<ProjectResource>().ToList())
        aspireBuilder.Resources.Remove(res);

    aspireApp = await aspireBuilder.BuildAsync(testContext.CancellationToken);
    await aspireApp.StartAsync(testContext.CancellationToken);

    // Get connection strings and set them as environment variables
    Environment.SetEnvironmentVariable("ConnectionStrings__postgresdb", 
        await aspireApp.GetConnectionStringAsync("postgresdb", testContext.CancellationToken));
    
    await aspireApp.ResourceNotifications.WaitForResourceAsync("postgresdb", 
        KnownResourceStates.Running, testContext.CancellationToken);
}
```

**Key Benefits**:
- Tests run against real infrastructure (databases, storage) provisioned by Aspire
- Infrastructure matches production more closely than in-memory alternatives
- Connection strings are automatically retrieved from Aspire
- Tests can override backend services using `AppTestServer` when needed

## Running the Application with Aspire

### Option 1: Run AppHost Project

1. Set `Boilerplate.Server.AppHost` as the startup project in Visual Studio
2. Press F5 or click Run
3. Aspire will:
   - Start all infrastructure resources (databases, storage, etc.)
   - Start all application projects
   - Open the Aspire Dashboard in your browser

### Option 2: Command Line

```powershell
cd src/Server/Boilerplate.Server.AppHost
dotnet run
```

### What Happens When You Run AppHost?

1. **Docker Containers Start**: Aspire starts all required Docker containers (databases, storage, tools)
2. **Connection Strings Generated**: Aspire generates connection strings and injects them into your projects
3. **Projects Start**: Your application projects start with proper configuration
4. **Dashboard Opens**: The Aspire Dashboard opens automatically in your browser
5. **Service Discovery**: All services can discover and communicate with each other

## Best Practices

### 1. Use Data Volumes for Persistence

Always use `.WithDataVolume()` to persist data across container restarts:

```csharp
var postgresDatabase = builder.AddPostgres("postgresserver")
    .WithDataVolume()  // ✅ Data persists across restarts
    .AddDatabase("postgresdb");
```

### 2. Use Health Checks Only in Development

Health check endpoints can expose sensitive information. Only enable them in development:

```csharp
if (builder.Environment.IsDevelopment())
{
    serverWebProject.WithHttpHealthCheck("/alive");
}
```

See [https://aka.ms/dotnet/aspire/healthchecks](https://aka.ms/dotnet/aspire/healthchecks) for security details.

### 3. Use Dev Tunnels for External Integration Testing

When testing OAuth, webhooks, or mobile apps that need to connect to your local backend:

```csharp
if (builder.ExecutionContext.IsRunMode)
{
    var tunnel = builder.AddDevTunnel("web-dev-tunnel")
        .WithAnonymousAccess()
        .WithReference(serverWebProject.WithHttpEndpoint(name: "devTunnel").GetEndpoint("devTunnel"));
}
```

### 4. Separate Development and Production Resources

Use `builder.ExecutionContext.IsRunMode` to add development-only resources:

```csharp
if (builder.ExecutionContext.IsRunMode)
{
    // Development-only tools
    var mailpit = builder.AddMailPit("smtp");
    builder.AddProject("clientwebwasm", "...").WithExplicitStart();
}
```

### 5. Clean Up Docker Volumes When Changing Passwords

If you change database passwords in `appsettings.Development.json`, you need to delete the Docker volumes:

```powershell
docker volume ls  # List all volumes
docker volume rm <volume_name>  # Remove specific volume
```

Or remove all unused volumes:
```powershell
docker volume prune
```

## Common Scenarios

### Adding a New Database

1. Add the appropriate NuGet package to `Boilerplate.Server.AppHost.csproj`
2. Configure the database in `Program.cs`:

```csharp
var newDb = builder.AddPostgres("newserver")
    .WithDataVolume()
    .AddDatabase("newdb");

// Wire it up to your project
serverApiProject.WithReference(newDb).WaitFor(newDb);
```

3. Update `appsettings.Development.json` with credentials if needed

### Adding a New Service

1. Add the service as a project reference in `Boilerplate.Server.AppHost.csproj`
2. Register it in `Program.cs`:

```csharp
var newService = builder.AddProject("newservice", "../Path/To/NewService.csproj")
    .WithExternalHttpEndpoints();

// Add dependencies
newService.WithReference(postgresDatabase).WaitFor(postgresDatabase);

if (builder.Environment.IsDevelopment())
{
    newService.WithHttpHealthCheck("/alive");
}
```

### Debugging a Specific Service

When running through AppHost, you can still attach the debugger to individual services:

1. In Visual Studio: Debug → Attach to Process
2. Find your service process (e.g., `Boilerplate.Server.Api`)
3. Attach debugger

Or use `WithExplicitStart()` to manually control when a service starts:

```csharp
builder.AddProject("clientwebwasm", "../../Client/Boilerplate.Client.Web/Boilerplate.Client.Web.csproj")
    .WithExplicitStart();  // Won't start automatically - you start it manually from the dashboard
```

## Aspire vs. Traditional Development

### Without Aspire (Traditional Approach)

- Manually install and configure databases
- Manually manage connection strings in appsettings.json
- Manually start each service/project
- Manually configure service-to-service communication
- Limited observability (separate logging for each service)
- No integrated infrastructure management

### With Aspire

- ✅ Automatic database provisioning with admin tools
- ✅ Automatic connection string management
- ✅ Single command to start entire application
- ✅ Automatic service discovery
- ✅ Unified observability dashboard (logs, metrics, traces)
- ✅ Integrated infrastructure management with data persistence
- ✅ Development tools included (MailPit, Dev Tunnels, Health Checks)

## Troubleshooting

### Docker Not Running

**Error**: `Docker is not running`

**Solution**: Ensure Docker Desktop is running before starting the AppHost project.

### Port Conflicts

**Error**: `Address already in use`

**Solution**: Stop other services using the same ports, or modify the port configuration in `Program.cs`:

```csharp
serverWebProject.WithHttpEndpoint(port: 5001);
```

### Data Not Persisting

**Problem**: Database data is lost after container restart

**Solution**: Ensure you're using `.WithDataVolume()`:

```csharp
var db = builder.AddPostgres("server")
    .WithDataVolume()  // ✅ Add this
    .AddDatabase("db");
```

### Can't Access Aspire Dashboard

**Problem**: Dashboard URL doesn't open

**Solution**: Look for the dashboard URL in the console output when starting AppHost. It's typically `http://localhost:15XXX`.

## Additional Resources

- **Official Aspire Documentation**: [https://learn.microsoft.com/dotnet/aspire/](https://learn.microsoft.com/dotnet/aspire/)
- **Aspire Samples**: [https://github.com/dotnet/aspire-samples](https://github.com/dotnet/aspire-samples)
- **Service Defaults Documentation**: [https://aka.ms/dotnet/aspire/service-defaults](https://aka.ms/dotnet/aspire/service-defaults)
- **Health Checks Security**: [https://aka.ms/dotnet/aspire/healthchecks](https://aka.ms/dotnet/aspire/healthchecks)

## Summary

.NET Aspire transforms local development for distributed applications by providing:

1. **Simplified Infrastructure Management**: Automatically provision databases, storage, and tools
2. **Service Orchestration**: Start and connect all services with a single command
3. **Developer Productivity**: Integrated admin tools, email testing, and dev tunnels
4. **Observability**: Unified dashboard for logs, metrics, and traces
5. **Production Parity**: Tests run against real infrastructure that matches production

The boilerplate template leverages Aspire to provide a complete, production-ready development experience out of the box. All infrastructure resources are containerized, versioned, and persist across restarts, ensuring a consistent and reliable development environment.

---

**Next Steps**: 
- Run the `Boilerplate.Server.AppHost` project and explore the Aspire Dashboard
- Experiment with adding new resources (databases, services, tools)
- Review the health checks and observability features
- Try testing with the integrated infrastructure

Do you have any questions about .NET Aspire, or shall we proceed to Stage 21 (.NET MAUI - Blazor Hybrid)?
