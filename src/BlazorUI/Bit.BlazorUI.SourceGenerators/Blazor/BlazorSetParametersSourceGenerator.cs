using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Bit.BlazorUI.SourceGenerators.Blazor;

[Generator]
public class BlazorSetParametersSourceGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not BlazorParameterPropertySyntaxReceiver receiver) return;

        foreach (var propertiesGroup in receiver.Properties.GroupBy(p => p.PropertySymbol.ContainingType, SymbolEqualityComparer.Default))
        {
            var properties = propertiesGroup.ToList();

            CheckTwoWayBoundParameter(properties);

            if (propertiesGroup.Key == null) continue;

            string classSource = GeneratePartialClassToOverrideSetParameters((INamedTypeSymbol)propertiesGroup.Key, properties);
            context.AddSource($"{propertiesGroup.Key.Name}_SetParametersAsync.AutoGenerated.cs", SourceText.From(classSource, Encoding.UTF8));
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new BlazorParameterPropertySyntaxReceiver());
    }

    private static string GeneratePartialClassToOverrideSetParameters(INamedTypeSymbol classSymbol, List<BitProperty> properties)
    {
        string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        bool isBase = classSymbol.BaseType?.ToDisplayString() == "Microsoft.AspNetCore.Components.ComponentBase";

        StringBuilder source = new StringBuilder($@"using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

namespace {namespaceName}
{{
    public partial class {GetClassName(classSymbol)}
    {{
        [global::System.Diagnostics.DebuggerNonUserCode]
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
        public override Task SetParametersAsync(ParameterView parameters)
        {{
");
        foreach (var property in properties.Where(p => p.IsTwoWayBoundProperty))
        {
            source.AppendLine($"            {property.PropertySymbol.Name}HasBeenSet = false;");
        }
        source.AppendLine("            var parametersDictionary = parameters.ToDictionary() as Dictionary<string, object>;");
        source.AppendLine("            foreach (var parameter in parametersDictionary!)");
        source.AppendLine("            {");
        source.AppendLine("                switch (parameter.Key)");
        source.AppendLine("                {");

        // create cases for each property
        foreach (var prop in properties)
        {
            var propName = prop.PropertySymbol.Name;
            var varName = $"@{prop.PropertySymbol.Name.ToLower()}";
            source.AppendLine($"                    case nameof({propName}):");
            if (prop.IsTwoWayBoundProperty)
            {
                source.AppendLine($"                       {propName}HasBeenSet = true;");
            }

            source.AppendLine($"                       var {varName} = parameter.Value is null ? default! : ({prop.PropertySymbol.Type.ToDisplayString()})parameter.Value;");

            if (prop.ResetClassBuilder)
            {
                source.AppendLine($"                       if ({propName} != {varName}) ClassBuilder.Reset();");
            }
            if (prop.ResetStyleBuilder)
            {
                source.AppendLine("                       if ({propName} != {varName}) StyleBuilder.Reset();");
            }
            source.AppendLine($"                       {propName} = {varName};");
            source.AppendLine("                       parametersDictionary.Remove(parameter.Key);");
            source.AppendLine("                       break;");
        }

        source.AppendLine("                }");
        source.AppendLine("            }");

        if (isBase)
        {
            source.AppendLine("            return base.SetParametersAsync(ParameterView.Empty);");
        }
        else
        {
            source.AppendLine("            return base.SetParametersAsync(ParameterView.FromDictionary(parametersDictionary as IDictionary<string, object?>));");
        }

        source.AppendLine("        }");
        source.AppendLine("    }");
        source.AppendLine("}");

        return source.ToString();
    }

    private static string GetClassName(INamedTypeSymbol classSymbol)
    {
        StringBuilder sbName = new StringBuilder(classSymbol.Name);

        if (classSymbol.IsGenericType)
        {
            sbName.Append('<');
            sbName.Append(string.Join(", ", classSymbol.TypeArguments.Select(s => s.Name)));
            sbName.Append('>');
        }

        return sbName.ToString();
    }

    private static void CheckTwoWayBoundParameter(List<BitProperty> properties)
    {
        foreach (var property in properties)
        {
            var propName = $"{property.PropertySymbol.Name}Changed";
            var propType = $"Microsoft.AspNetCore.Components.EventCallback<{property.PropertySymbol.Type.ToDisplayString()}>";
            property.IsTwoWayBoundProperty = properties.Any(p => p.PropertySymbol.Name == propName && p.PropertySymbol.Type.ToDisplayString() == propType);
        }
    }
}
